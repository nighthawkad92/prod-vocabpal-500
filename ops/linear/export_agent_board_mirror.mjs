import path from "node:path";
import process from "node:process";

import {
  fetchTeamIssues,
  getRequiredEnv,
  loadLinearConfig,
  normalizeStateName,
  parseCliArgs,
  resolveFromRoot,
  taskPrefixFromTitle,
  writeTextFile,
} from "./client.mjs";

function parseDependsOnFromDescription(description) {
  const match = String(description ?? "").match(/- Depends On:\s*(.+)$/m);
  if (!match) return "-";
  const value = match[1].trim();
  return value.length > 0 ? value : "-";
}

function parseNotesFromDescription(description) {
  const marker = "### Notes";
  const raw = String(description ?? "");
  const markerIndex = raw.indexOf(marker);
  if (markerIndex < 0) return "Synced from Linear";

  const notes = raw.slice(markerIndex + marker.length).trim();
  if (!notes) return "Synced from Linear";

  const firstLine = notes.split(/\r?\n/)[0].trim();
  return firstLine.length > 0 ? firstLine : "Synced from Linear";
}

function resolveOwner(issue, config) {
  const roleLabel = issue.labels?.nodes?.find((entry) => entry.name.startsWith("role:"));
  if (!roleLabel) {
    return issue.assignee?.name ?? "-";
  }

  const ownerEntry = Object.entries(config.ownerRoleMap ?? {})
    .find(([, label]) => label === roleLabel.name);

  return ownerEntry?.[0] ?? issue.assignee?.name ?? "-";
}

function compareTaskIds(a, b) {
  const normalize = (value) => {
    const match = value.match(/^([A-Z]+)-(\d+)$/);
    if (!match) return { prefix: value, number: Number.POSITIVE_INFINITY };
    return { prefix: match[1], number: Number.parseInt(match[2], 10) };
  };

  const left = normalize(a.taskId);
  const right = normalize(b.taskId);

  if (left.prefix !== right.prefix) return left.prefix.localeCompare(right.prefix);
  return left.number - right.number;
}

async function main() {
  const args = parseCliArgs();
  const teamId = getRequiredEnv("LINEAR_TEAM_ID");
  const config = await loadLinearConfig();

  const outputPath = args.output
    ? path.resolve(process.cwd(), String(args.output))
    : resolveFromRoot(config.migration?.legacyMirrorOutput ?? "knowledge-base/linear/agent_board_mirror.md");

  const issues = await fetchTeamIssues({ teamId });

  const rows = issues.map((issue) => {
    const { taskId, summary } = taskPrefixFromTitle(issue.title ?? "");

    return {
      taskId: taskId ?? issue.identifier,
      title: summary || issue.title,
      owner: resolveOwner(issue, config),
      dependsOn: parseDependsOnFromDescription(issue.description),
      state: normalizeStateName(issue.state?.name ?? "TODO"),
      notes: parseNotesFromDescription(issue.description),
    };
  });

  rows.sort(compareTaskIds);

  const header = [
    "# Agent Coordination Board Mirror (Generated From Linear)",
    "",
    "This file is generated by `npm run linear:migration:export-mirror`.",
    "Do not edit manually.",
    "",
    "| Task ID | Title | Owner | Depends On | State | Notes |",
    "|---|---|---|---|---|---|",
  ];

  const body = rows.map((row) =>
    `| ${row.taskId} | ${row.title} | ${row.owner} | ${row.dependsOn} | ${row.state} | ${row.notes} |`
  );

  await writeTextFile(outputPath, [...header, ...body, ""].join("\n"));
  process.stdout.write(`Wrote Linear mirror board: ${outputPath}\n`);
}

main().catch((error) => {
  process.stderr.write(`${error instanceof Error ? error.message : String(error)}\n`);
  process.exitCode = 1;
});
